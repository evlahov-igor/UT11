
#Область ПрограммныйИнтерфейс

// Выполняет запись всех интеграционных сообщений в РС "КР_ИсходящиеСообщения"
//
// Параметры:
//  Источник  - Объект, НаборЗаписей - Записываемая сущность дял регистрации объекта
//  Отказ  - Булево - Признак ошибки
//	ПараметрыВыгрузкиОбъекта  - Массив структур - Структура с собранными интеграционными данными
//			см. КР_ОбменRabbitПодготовкаДанных.ПолучитьНастройкиВыгрузкиОбъекта
//
Процедура ЗарегистрироватьИсходящиеСообщенияОбмена(Источник, Отказ, ПараметрыВыгрузкиОбъекта) Экспорт

	Для Каждого СтруктураВыгрузки Из ПараметрыВыгрузкиОбъекта Цикл
		Для Каждого СообщениеОбмена Из СтруктураВыгрузки.МассивСообщений Цикл			
			ЗарегистрироватьИсходящееСообщениеОбмена(СтруктураВыгрузки.ТочкаОбмена, СообщениеОбмена, Отказ);			
		КонецЦикла;		
	КонецЦикла;
	
КонецПроцедуры

// Выполняет запись одного интеграционного сообщения в РС "КР_ИсходящиеСообщения"
//
// Параметры:
//  ТочкаОбмена  - Строка - Точка обмена RabbitMQ, в которую необходимо отправить сообщение
//  СообщениеОбмена  - Структура - структура интеграционного сообщения.
//			см. КР_ОбменRabbitОбработкаСообщенийОбмена.ПолучитьСтруктуруСообщения 
//  Отказ  - Булево - Признак ошибки
//
Процедура ЗарегистрироватьИсходящееСообщениеОбмена(ТочкаОбмена, СообщениеОбмена, Отказ) Экспорт

	Если СообщениеОбмена = Неопределено Или Отказ Тогда
		Возврат;
	КонецЕсли;	
	
	//АтрибутыRabbit = КР_ФункцииРаботыJSON.СериализоватьОбъект(СообщениеОбмена.Атрибуты);	
	//АтрибутыRabbit = "{""x-match"": ""all""}";	
	//АтрибутыRabbit = КР_ФункцииРаботыJSON.КонвертироватьСтруктуруВJSONОбъект(СообщениеОбмена.Маршрутизация);
	
	ТекстСообщения = НСтр("ru='Сообщение записано в очередь к интеграции'");
	ДобавитьЗаписьВЛог(СообщениеОбмена, ТекстСообщения);
	
	МенеджерЗаписи = РегистрыСведений.КР_ИсходящиеСообщения.СоздатьМенеджерЗаписи();
// << 25.12.2023 Петухов А.В., Фактор, #3553
	//ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СообщениеОбмена);
	// Вариант 1 - сжимаем всегда
	ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СообщениеОбмена,,"ТелоСообщения");
	МенеджерЗаписи.ТелоСообщения = "";
	МенеджерЗаписи.ТелоСообщенияСжатое = Новый ХранилищеЗначения(СообщениеОбмена.ТелоСообщения, Новый СжатиеДанных (9));

	//// Вариант 2 - сжимаем в зависимости от настроек точки отбмена.
	//// Если для указанной точки обмена настроена необходимость сжимать сообщения - 
	//// сжимать тело сообщения и записывать его в регистр вместо несжатого тела сообщения
	//УсловиеСжатияВыполнено = КР_ДополнительныеНастройкиПовтИсп.ИспользоватьСжатиеСообщений(ТочкаОбмена);
	//Если УсловиеСжатияВыполнено Тогда
	//	ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СообщениеОбмена,,"ТелоСообщения");
	//	МенеджерЗаписи.ТелоСообщения = "";
	//	МенеджерЗаписи.ТелоСообщенияСжатое = Новый ХранилищеЗначения(СообщениеОбмена.ТелоСообщения, Новый СжатиеДанных (9));
	//Иначе
	//	ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СообщениеОбмена);
	//КонецЕсли;
// >> 25.12.2023 Петухов А.В., Фактор, #3553
	//МенеджерЗаписи.Маршрутизация = АтрибутыRabbit;	
	
	// A2105505-1404 
	//СсылкиНаОбъекты = Новый ХранилищеЗначения(СообщениеОбмена.СсылкиНаОбъекты, Новый СжатиеДанных(9));
	МодульКонвертации = КР_ОбщегоНазначениеСервер;
	Данные = Новый Массив;
	Для Каждого Ссылка Из СообщениеОбмена.СсылкиНаОбъекты Цикл 
		Данные.Добавить(МодульКонвертации.СсылкаВСтруктуру(Ссылка));
	КонецЦикла;
	СсылкиНаОбъекты = МодульКонвертации.ДанныеВJSON(Данные);
    //
	МенеджерЗаписи.СписокСсылокНаОбъекты = СсылкиНаОбъекты;
	МенеджерЗаписи.ТочкаОбмена = ТочкаОбмена;
	
	// A2105505-1909 
	// Доработан учет ошибки при выборе состояния 
	Если Не СообщениеОбмена.ЕстьОшибка Тогда 
		Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Зарегистрировано;   
	ИначеЕсли ЗначениеЗаполнено(СообщениеОбмена.УточненноеСостояние) Тогда 
		Состояние = СообщениеОбмена.УточненноеСостояние;   		
	Иначе	
		Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Ошибка;   
	КонецЕсли;
	
	МенеджерЗаписи.Состояние = Состояние;
	//
		
	МенеджерЗаписи.Записать(Истина);		
	
КонецПроцедуры

// Выполняет запись признака отправки исходящего сообщения
//
// Параметры:
//  СтруктураСообщения  - Структура - данные интеграционного сообщения
//			см. КР_ОбменRabbitОбработкаСообщенийОбмена.СформироватьСтруктуруИсходящегоСообщения
//  ИнтеграционнаяИнформация  - Структура - общая интеграционная информация
//			см. КР_ОбменRabbitВзаимодействиеСАдаптером.НачатьИтерациюОбмена 
//
Процедура ЗарегистрироватьОтправкуСообщенияОбмена(СтруктураСообщения, ИнтеграционнаяИнформация) Экспорт

	МенеджерЗаписи = РегистрыСведений.КР_ИсходящиеСообщения.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.КлючСообщения = СтруктураСообщения.КлючСообщения;
	
	МенеджерЗаписи.Прочитать();
	
	МенеджерЗаписи.Логирование = СтруктураСообщения.Логирование;
	МенеджерЗаписи.ДатаОтправки = СтруктураСообщения.ДатаОтправки;
	МенеджерЗаписи.КоличествоПопытокОтправки = МенеджерЗаписи.КоличествоПопытокОтправки + 1;
	
	Если СтруктураСообщения.ЕстьОшибка Тогда
		Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Ошибка;
		ИнтеграционнаяИнформация.КоличествоОшибок = ИнтеграционнаяИнформация.КоличествоОшибок + 1;
	Иначе
		Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Отправлено;
		ИнтеграционнаяИнформация.ОтправленоСообщений = ИнтеграционнаяИнформация.ОтправленоСообщений + 1;
	КонецЕсли;
	
	МенеджерЗаписи.Состояние = Состояние;
	МенеджерЗаписи.Записать(Истина);
	
КонецПроцедуры

// Возвращает данные для отправки сообщений в RabbitMQ
//
// Возвращаемое значение:
//   Соответствие:
//			Ключ - Имя точки обмена
//			Значение - массив исходящих сообщений. Значение массива - структура:
//				см. КР_ОбменRabbitОбработкаСообщенийОбмена.СформироватьСтруктуруИсходящегоСообщения
//
Функция ПолучитьДанныеИсходящихСообщений(МассивКлючей, ИнтеграционнаяИнформация) Экспорт
	
	ДанныеСообщений = Новый Соответствие;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КР_ИсходящиеСообщения.КлючСообщения КАК КлючСообщения,
		|	КР_ИсходящиеСообщения.ТелоСообщения КАК ТелоСообщения,
// << 25.12.2023 Петухов А.В., Фактор, #3553
		|	КР_ИсходящиеСообщения.ТелоСообщенияСжатое КАК ТелоСообщенияСжатое,
// >> 25.12.2023 Петухов А.В., Фактор, #3553
		|	КР_ИсходящиеСообщения.ТипДанных КАК ТипДанных,
		|	КР_ИсходящиеСообщения.Маршрутизация КАК Маршрутизация,
		|	КР_ИсходящиеСообщения.ТочкаОбмена КАК ТочкаОбмена,
		|	КР_ИсходящиеСообщения.МоментРегистрации КАК МоментРегистрации,
		|	КР_ИсходящиеСообщения.ДатаРегистрации КАК ДатаСообщения,
		|	КР_ИсходящиеСообщения.Логирование КАК Логирование
		|ИЗ
		|	РегистрСведений.КР_ИсходящиеСообщения КАК КР_ИсходящиеСообщения
		|ГДЕ
		|	КР_ИсходящиеСообщения.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Зарегистрировано)
		|	%МассивКлючей%
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	КР_ИсходящиеСообщения.КлючСообщения,
		|	КР_ИсходящиеСообщения.ТелоСообщения,
// << 25.12.2023 Петухов А.В., Фактор, #3553
		|	КР_ИсходящиеСообщения.ТелоСообщенияСжатое,
// >> 25.12.2023 Петухов А.В., Фактор, #3553
		|	КР_ИсходящиеСообщения.ТипДанных,
		|	КР_ИсходящиеСообщения.Маршрутизация,
		|	КР_ИсходящиеСообщения.ТочкаОбмена,
		|	КР_ИсходящиеСообщения.МоментРегистрации,
		|	КР_ИсходящиеСообщения.ДатаРегистрации,
		|	КР_ИсходящиеСообщения.Логирование
		|ИЗ
		|	РегистрСведений.КР_ИсходящиеСообщения КАК КР_ИсходящиеСообщения
		|ГДЕ
		|	КР_ИсходящиеСообщения.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Ошибка)
		|	И ДОБАВИТЬКДАТЕ(КР_ИсходящиеСообщения.ДатаОтправки, МИНУТА, &ИтервалПовтораПриОшибкеВМинутах) <= &ТекущаяДата
		|	И КР_ИсходящиеСообщения.КоличествоПопытокОтправки < &КоличествоПовторовПриОшибке
		|ИТОГИ ПО
		|	ТочкаОбмена";
	
	
	Если МассивКлючей = Неопределено Тогда
		ПодстрокаЗамены = "";	
	Иначе
		ПодстрокаЗамены = "И КР_ИсходящиеСообщения.КлючСообщения В (&МассивКлючей)";	
		запрос.УстановитьПараметр("МассивКлючей", МассивКлючей);
	КонецЕсли;
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "%МассивКлючей%", ПодстрокаЗамены);
	
	Запрос.УстановитьПараметр("КоличествоПовторовПриОшибке", ИнтеграционнаяИнформация.НастройкиПодключения.КоличествоПовторовПриОшибке);
	Запрос.УстановитьПараметр("ИтервалПовтораПриОшибкеВМинутах", ИнтеграционнаяИнформация.НастройкиПодключения.ИтервалПовтораПриОшибкеВМинутах);
	Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат ДанныеСообщений;
	КонецЕсли;
	
	ВыборкаТочки = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	НаименованиеОтправителя = ИнтеграционнаяИнформация.ТекущаяИБНаименование;
	
	Пока ВыборкаТочки.Следующий() Цикл
		ВыборкаСообщения = ВыборкаТочки.Выбрать();
		МассивСообщений = Новый Массив;
		Пока ВыборкаСообщения.Следующий() Цикл		
			СтруктураСообщения = СформироватьСтруктуруИсходящегоСообщения(ВыборкаСообщения, НаименованиеОтправителя);		
			МассивСообщений.Добавить(СтруктураСообщения);
		КонецЦикла;
		
		ДанныеСообщений.Вставить(ВыборкаТочки.ТочкаОбмена, МассивСообщений);
	КонецЦикла;
	
	Возврат ДанныеСообщений;
	
КонецФункции

// Запиывает в РС "КР_ВходящиеСообщения" информацию о полученном из RabbitMQ сообщении
//
// Параметры:
//  ИмяОчереди  - Строка - Имя читаемой очереди из RabbitMQ
//  ВходящееСообщение  - Строка - Полученное из RabbitMQ сообщение в формате JSON
//  ИнтеграционнаяИнформация  - Структура - общая интеграционная информация
//			см. КР_ОбменRabbitВзаимодействиеСАдаптером.НачатьИтерациюОбмена 
//
// Возвращаемое значение:
//   Булево   - Признак успеха обработки полученного сообщения
//
Функция ЗарегистрироватьВходящееСообщение(ИмяОчереди, ВходящееСообщение, ИнтеграционнаяИнформация, ТекстСообщения) Экспорт

	Если Не ЗначениеЗаполнено(ВходящееСообщение) Тогда
		Возврат Истина;
	КонецЕсли;

	Попытка		
		СообщениеОбъект = КР_ФункцииРаботыJSON.ДесериализоватьXDTOИзJSON(ВходящееСообщение);		
	Исключение		
		СообщениеОбъект = Неопределено;
		ТекстСообщения = НСтр("ru='Не удалось прочитать XDTO пакет сообщения из XML по причине:
			|%1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ДобавитьЗаписьВЛог(ИнтеграционнаяИнформация, ТекстСообщения, ТипЗаписиВЛог_Ошибка());
		ИнтеграционнаяИнформация.КоличествоОшибок = ИнтеграционнаяИнформация.КоличествоОшибок + 1;
		Возврат Ложь;
	КонецПопытки;
	
	Попытка
		
		СообщениеID = СообщениеОбъект.ID; 
		Если Не ЗначениеЗаполнено(СообщениеID) Тогда
			ТекстСообщения = НСтр("ru='В полученном сообщении отсутствует ID сообщения'");			
			ДобавитьЗаписьВЛог(ИнтеграционнаяИнформация, ТекстСообщения, ТипЗаписиВЛог_Ошибка());
			ИнтеграционнаяИнформация.КоличествоОшибок = ИнтеграционнаяИнформация.КоличествоОшибок + 1;
			Возврат Ложь;			
		КонецЕсли;
		
		Если СообщениеОбъект.Sender = "" Тогда
			ТекстСообщения = НСтр("ru='В полученном сообщении отсутствует Sender'");			
			ДобавитьЗаписьВЛог(ИнтеграционнаяИнформация, ТекстСообщения, ТипЗаписиВЛог_Ошибка());
			ИнтеграционнаяИнформация.КоличествоОшибок = ИнтеграционнаяИнформация.КоличествоОшибок + 1;
			Возврат Ложь;	
		КонецЕсли;
		
		ТекущаяИБ = КР_ОбменRabbitОбщиеМеханизмыПовтИсп.ПолучитьТекущуюИнформационнуюБазу();		
		Отправитель = КР_ОбменRabbitОбщиеМеханизмыПовтИсп.ПолучитьИнформационнуюБазу(СообщениеОбъект.Sender);		
		Если Отправитель = ТекущаяИБ.Ссылка Тогда
			ТекстСообщения = НСтр("ru='Получено сообщение, сгенерированное текущей информационной базой'");			
// << 18.12.2023 Петухов А.В., Фактор, #3530
			//ДобавитьЗаписьВЛог(ИнтеграционнаяИнформация, ТекстСообщения, ТипЗаписиВЛог_Ошибка());
			//ИнтеграционнаяИнформация.КоличествоОшибок = ИнтеграционнаяИнформация.КоличествоОшибок + 1;
			ДобавитьЗаписьВЛог(ИнтеграционнаяИнформация, ТекстСообщения, ТипЗаписиВЛог_Информация());
			ИнтеграционнаяИнформация.ЕстьСообщенияОтСебя = Истина;
// >> 18.12.2023 Петухов А.В., Фактор, #3530
			Возврат Ложь;
		КонецЕсли;
		
		РазрешенныеОтправители = ИнтеграционнаяИнформация.НастройкиПодключения.РазрешенныеОтправители;
		Если РазрешенныеОтправители.Количество() > 0 
			И РазрешенныеОтправители.Найти(Отправитель) = Неопределено Тогда
			ТекстСообщения = НСтр("ru='Полученное сообщение не может быть загружено из-за запрета загрузки сообщений от отправителя %1'");			
			ТекстСообщения = СтрШаблон(ТекстСообщения, Отправитель);
			ДобавитьЗаписьВЛог(ИнтеграционнаяИнформация, ТекстСообщения, ТипЗаписиВЛог_Ошибка());
			ИнтеграционнаяИнформация.КоличествоОшибок = ИнтеграционнаяИнформация.КоличествоОшибок + 1;
			Возврат Ложь;
		КонецЕсли;
	
		// это полноценное входящее сообщение
		МенеджерЗаписи = РегистрыСведений.КР_ВходящиеСообщения.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.КлючСообщения = СообщениеОбъект.ID;
		
		// A2105505-1533
		// МенеджерЗаписи.ОчередьОбмена = ИмяОчереди;
		УстановитьОчередьОбмена(ИмяОчереди, СообщениеОбъект, МенеджерЗаписи);
		//
		
		МенеджерЗаписи.Отправитель = Отправитель;
		
		МенеджерЗаписи.Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Зарегистрировано;
		
		МенеджерЗаписи.МоментРегистрации = СообщениеОбъект.TimeID; 
		МенеджерЗаписи.ДатаРегистрации = СообщениеОбъект.Time;
		МенеджерЗаписи.ДатаОтправки = СообщениеОбъект.SendTime; 
		МенеджерЗаписи.ДатаПолучения = ТекущаяДатаСеанса();
		
		Если Не ЗначениеЗаполнено(МенеджерЗаписи.МоментРегистрации) Тогда
			МенеджерЗаписи.МоментРегистрации = ТекущаяУниверсальнаяДатаВМиллисекундах();	
		КонецЕсли;
		Если Не ЗначениеЗаполнено(МенеджерЗаписи.ДатаРегистрации) Тогда
			МенеджерЗаписи.ДатаРегистрации = МенеджерЗаписи.ДатаПолучения;	
		КонецЕсли;
		Если Не ЗначениеЗаполнено(МенеджерЗаписи.ДатаОтправки) Тогда
			МенеджерЗаписи.ДатаОтправки = МенеджерЗаписи.ДатаПолучения;	
		КонецЕсли;
		
		МенеджерЗаписи.ТипДанных = СообщениеОбъект.DataType;
		
		// В сообщении обмена проверяем заполнено ли свойство DataPacked содержащее тело сообщение,
		// если не заполнено, считаем что тело сообщения в свойстве Data. 
		
		// 28.11.2023 Марченко С.Н., КРОК, JIRA№A2105505-2544
		// Исправление ошибки, возникающей при варианте когда свойства "DataPacked" нет в сообщении
		Если Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(СообщениеОбъект, "DataPacked")
			Или Не ЗначениеЗаполнено(СообщениеОбъект.DataPacked) Тогда 
			МенеджерЗаписи.ТелоСообщения = СообщениеОбъект.Data;
		Иначе	
		// Получим тело сообщения из ХранилищаЗначений
// << 25.12.2023 Петухов А.В., Фактор, #3553
			// Если входящее сообщение содержит данные в сжатом виде (заполнено свойство DataPacked),
			// то не нужно его распаковывать сразу, а сохранять в регистр КР_ВходящиеСообщения в сжатом виде
			//МенеджерЗаписи.ТелоСообщения = СообщениеОбъект.DataPacked.Получить(); 
			МенеджерЗаписи.ТелоСообщения = "";
			МенеджерЗаписи.ТелоСообщенияСжатое = СообщениеОбъект.DataPacked;
// >> 25.12.2023 Петухов А.В., Фактор, #3553
		КонецЕсли;
		
		МенеджерЗаписи.Логирование = СообщениеОбъект.Log; 
	
		МенеджерЗаписи.Записать(Истина);			
		
		ИнтеграционнаяИнформация.ПолученоСообщений = ИнтеграционнаяИнформация.ПолученоСообщений + 1;
		
	Исключение
		
		ТекстСообщения = НСтр("ru='Ошибка записи Входящего сообщения:
			|%1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ДобавитьЗаписьВЛог(ИнтеграционнаяИнформация, ТекстСообщения, ТипЗаписиВЛог_Ошибка());
		ИнтеграционнаяИнформация.КоличествоОшибок = ИнтеграционнаяИнформация.КоличествоОшибок + 1;
		Возврат Ложь;	
		
	КонецПопытки;	
	
	Возврат Истина;
	
КонецФункции

// Метод регламентного задания "КР_ОбменRabbitРазборСообщений".
// Выполняет последовательный разбор полученных сообщений обмена
//
Процедура ОбработатьВходящиеСообщения(МассивКлючей = Неопределено) Экспорт 
	
	Если ПолучитьФункциональнуюОпцию("КР_ИспользуетсяИнтеграцияRabbitMQ") <> Истина Тогда
		Возврат;	
	КонецЕсли;

	// << 03.07.2024 Петухов А.В., Фактор, #4286
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.КР_ОбменRabbitРазборСообщений);
	// >> 03.07.2024 Петухов А.В., Фактор, #4286

	// << 24.07.2024 Петухов А.В., Фактор, #4316
	ТекущееСостояние = злОбновлениеКонфигурацииВызовСервера.СостояниеОбновления();
	Если Истина
		И ТекущееСостояние <> Неопределено
		И (ТекущееСостояние.Статус = Перечисления.злСтатусыОбновленияКонфигурации.ПолученФайлОбновления
			ИЛИ ТекущееСостояние.Статус = Перечисления.злСтатусыОбновленияКонфигурации.ВыполняетсяОбновление
			ИЛИ ТекущееСостояние.Статус = Перечисления.злСтатусыОбновленияКонфигурации.ПроцедураОбновленияЗавершенаСОшибкой)
	Тогда 
		ТекстСообщения = НСтр("ru='Обработка отменена. Статус обновления конфигурации на версию %1: %2'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ТекущееСостояние.Версия, ТекущееСостояние.Статус);
		ЗаписьЖурналаРегистрации("RabbitMQ.ОбработкаСообщений",УровеньЖурналаРегистрации.Предупреждение,,,ТекстСообщения);
		Возврат;
	КонецЕсли;
	// >> 24.07.2024 Петухов А.В., Фактор, #4316
	
	// Если передан массив ключей то это запуск в ручном режиме
	// Часть логики в этом режиме не выполняется
	Если МассивКлючей <> Неопределено Тогда
  		ОбработатьМассивВходящихСообщений(МассивКлючей); 
		Возврат;
	КонецЕсли;
	
	КР_ОбменRabbitОбработкаСообщенийОбмена.ПеренестиСообщенияВАрхив();
	
	ОбменRabbit = КР_ОбменRabbitОбщиеМеханизмыПовтИсп;
	ТекущаяИнформационнаяБаза = ОбменRabbit.ПолучитьТекущуюИнформационнуюБазу();
	НастройкиБазы = ОбменRabbit.ПолучитьНастройкиПодключенияКRabbit(ТекущаяИнформационнаяБаза.Ссылка); 
	
	Если НастройкиБазы = Неопределено Тогда
		ТекстСообщения = НСтр("ru='Не заданы параметры интеграции для ИБ: %1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ТекущаяИнформационнаяБаза.Ссылка);
		ЗаписьЖурналаРегистрации("RabbitMQ.ОбработкаСообщений",УровеньЖурналаРегистрации.Ошибка,,,ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	// Переведем сообщения в отдельный статус для остановки обработки
	ОстановитьОбработкуПоТаймауту(НастройкиБазы);
	
	// A2105505-1540 ОбработкаБезГруппировокПоТипамДанных
	Если Не НастройкиБазы.ОбработкаБезГруппировокПоТипамДанных Тогда  
		
		// Подготовим входящие сообщения для обработки фоновыми заданиями
		УстановитьИдентификаторГруппировкиДанных(НастройкиБазы); 
			
		ДанныеДляОбработки = Неопределено; // массив массивов ключей сообщений. 
		// Кажное будет обрабатываться отдельным фоновым заданием
		Если Не ПолучитьДанныеДляОбработкиФоновымиЗаданиямиСГруппировкой(ДанныеДляОбработки, НастройкиБазы) Тогда   
			Возврат;
		КонецЕсли;
		
		// Распределим данные по регламентный
		ПараметрыВыполнения = ДлительныеОперации.ПараметрыВыполненияПроцедуры(); 
		ПараметрыВыполнения.ОжидатьЗавершение = 0;
		ПараметрыВыполнения.ЗапуститьВФоне = Истина;
		ШаблонЗаголовкаЗадания = НСтр("ru = 'Обработка входящих сообщений RabbitMQ. Тип: %1 количество записей %2 (%3,%4)'");   
		ШаблонКлючаФоновогоЗадания = "%1 (%2)";
		
		ИтераторФоновыхЗаданий = 0; 
		Для Каждого ПакетДанных Из ДанныеДляОбработки Цикл  
			
			ИтераторФоновыхЗаданий = ИтераторФоновыхЗаданий + 1; 
			
			ПараметрыВыполнения.КлючФоновогоЗадания = СтрШаблон(ШаблонКлючаФоновогоЗадания,
				ПакетДанных.ИдентификаторГруппировкиДанных, ИтераторФоновыхЗаданий);  
			ПараметрыВыполнения.НаименованиеФоновогоЗадания = СтрШаблон(ШаблонЗаголовкаЗадания,
				ПакетДанных.ТипДанных, ПакетДанных.МассивКлючей.Количество(), ПакетДанных.ОчередьОбмена, ПакетДанных.Отправитель);
			
			ДлительныеОперации.ВыполнитьПроцедуру(ПараметрыВыполнения,
				"КР_ОбменRabbitОбработкаСообщенийОбмена.ОбработатьМассивВходящихСообщений", 
				ПакетДанных.МассивКлючей
			);

		КонецЦикла;	
		
	Иначе // A2105505-1540

			
		ДанныеДляОбработки = Неопределено; // массив массивов ключей сообщений. 
		// Кажное будет обрабатываться отдельным фоновым заданием
		Если Не ПолучитьДанныеДляОбработкиФоновымиЗаданиямиБезГруппировки(ДанныеДляОбработки, НастройкиБазы) Тогда   
			Возврат;
		КонецЕсли;
		
		// Распределим данные по регламентный
		ПараметрыВыполнения = ДлительныеОперации.ПараметрыВыполненияПроцедуры(); 
		ПараметрыВыполнения.ОжидатьЗавершение = 0;
		ПараметрыВыполнения.ЗапуститьВФоне = Истина;
		ШаблонЗаголовкаЗадания = НСтр("ru = 'Обработка входящих сообщений RabbitMQ. Количество записей %1'");   
		ШаблонКлючаФоновогоЗадания = "ОбработкаВходящихСообщений (%1)";
		
		Для Каждого КлючИЗначение Из ДанныеДляОбработки Цикл		

			ИдентификаторГруппировкиДанных = КлючИЗначение.Ключ;
			
			ПараметрыВыполнения.КлючФоновогоЗадания = СтрШаблон(ШаблонКлючаФоновогоЗадания,
				ИдентификаторГруппировкиДанных);  
			ПараметрыВыполнения.НаименованиеФоновогоЗадания = СтрШаблон(ШаблонЗаголовкаЗадания,
				КлючИЗначение.Значение.Количество());
			
			ДлительныеОперации.ВыполнитьПроцедуру(ПараметрыВыполнения,
				"КР_ОбменRabbitОбработкаСообщенийОбмена.ОбработатьМассивВходящихСообщений", 
				КлючИЗначение.Значение, , ИдентификаторГруппировкиДанных
			);

		КонецЦикла;	
		
	КонецЕсли;
	
КонецПроцедуры

// Метод регламентного задания КР_ОбменRabbitПовторныйРазбораСообщений 
Процедура ОбменRabbitПовторныйРазборСообщений() Экспорт	

	// << 03.07.2024 Петухов А.В., Фактор, #4286
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.КР_ОбменRabbitПовторныйРазборСообщений);
	// >> 03.07.2024 Петухов А.В., Фактор, #4286

	// << 24.07.2024 Петухов А.В., Фактор, #4316
	ТекущееСостояние = злОбновлениеКонфигурацииВызовСервера.СостояниеОбновления();
	Если Истина
		И ТекущееСостояние <> Неопределено
		И (ТекущееСостояние.Статус = Перечисления.злСтатусыОбновленияКонфигурации.ПолученФайлОбновления
			ИЛИ ТекущееСостояние.Статус = Перечисления.злСтатусыОбновленияКонфигурации.ВыполняетсяОбновление
			ИЛИ ТекущееСостояние.Статус = Перечисления.злСтатусыОбновленияКонфигурации.ПроцедураОбновленияЗавершенаСОшибкой)
	Тогда 
		ТекстСообщения = НСтр("ru='Обработка отменена. Статус обновления конфигурации на версию %1: %2'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ТекущееСостояние.Версия, ТекущееСостояние.Статус);
		ЗаписьЖурналаРегистрации("RabbitMQ.ПовторныйРазборСообщений",УровеньЖурналаРегистрации.Предупреждение,,,ТекстСообщения);
		Возврат;
	КонецЕсли;
	// >> 24.07.2024 Петухов А.В., Фактор, #4316
	
	ОбменRabbit = КР_ОбменRabbitОбщиеМеханизмыПовтИсп;
	ТекущаяИнформационнаяБаза = ОбменRabbit.ПолучитьТекущуюИнформационнуюБазу();
	НастройкиБазы = ОбменRabbit.ПолучитьНастройкиПодключенияКRabbit(ТекущаяИнформационнаяБаза.Ссылка);
	
	Если НастройкиБазы.КоличествоПовторовПриОшибке = 0 Тогда
		Возврат;
	КонецЕсли;
	
	СтатусыОбработки = Новый Массив;
	СтатусыОбработки.Добавить(Перечисления.КР_СостоянияСообщенийОбмена.Ошибка);
	// << 14.06.2023 Фомичев А.Е., КРОК, JIRA№A2105505-1788
	СтатусыОбработки.Добавить(Перечисления.КР_СостоянияСообщенийОбмена.ОшибкаПроведенияДокумента);
	// >> 14.06.2023 Фомичев А.Е., КРОК, JIRA№A2105505-1788
	
	СтатусыОбработки.Добавить(Перечисления.КР_СостоянияСообщенийОбмена.ОшибкаПоискаСсылки);
	СтатусыОбработки.Добавить(Перечисления.КР_СостоянияСообщенийОбмена.ТаймаутОбработки);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КР_ВходящиеСообщения.КлючСообщения КАК КлючСообщения
		|ИЗ
		|	РегистрСведений.КР_ВходящиеСообщения КАК КР_ВходящиеСообщения
		|ГДЕ
		|	КР_ВходящиеСообщения.Состояние В(&СтатусыОбработки)
		|	И КР_ВходящиеСообщения.КоличествоПопытокОбработки < &КоличествоПовторовПриОшибке
		|	И ДОБАВИТЬКДАТЕ(КР_ВходящиеСообщения.ДатаОбработки, МИНУТА, &ИтервалПовтораПриОшибкеВМинутах) <= &ТекущаяДатаСеанса";
	
	Запрос.УстановитьПараметр("КоличествоПовторовПриОшибке", НастройкиБазы.КоличествоПовторовПриОшибке);
	Запрос.УстановитьПараметр("ИтервалПовтораПриОшибкеВМинутах", НастройкиБазы.ИтервалПовтораПриОшибкеВМинутах);
	Запрос.УстановитьПараметр("ТекущаяДатаСеанса", ТекущаяДатаСеанса());
	Запрос.УстановитьПараметр("СтатусыОбработки", СтатусыОбработки);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	МассивКлючей = РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("КлючСообщения");	
	
	ОбработатьМассивВходящихСообщений(МассивКлючей, СтатусыОбработки);	
	
КонецПроцедуры

// Метод регламентного задания КР_ОбменRabbitУдалитьОшибкиПоискаДанных 
Процедура КР_ОбменRabbitУдалитьОшибкиПоискаДанных() Экспорт

	// << 03.07.2024 Петухов А.В., Фактор, #4286
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.КР_ОбменRabbitУдалитьОшибкиПоискаДанных);
	// >> 03.07.2024 Петухов А.В., Фактор, #4286
	
    ОбменRabbit = КР_ОбменRabbitОбщиеМеханизмыПовтИсп;
	ТекущаяИнформационнаяБаза = ОбменRabbit.ПолучитьТекущуюИнформационнуюБазу();
	НастройкиБазы = ОбменRabbit.ПолучитьНастройкиПодключенияКRabbit(ТекущаяИнформационнаяБаза.Ссылка);
	
	Если НастройкиБазы.ЛимитВДняхХраненияОшибокПоискаДанных = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КР_ОшибкиПоискаДанныхИнтеграции.ХэшИдентификаторЗаписи КАК ХэшИдентификаторЗаписи
		|ИЗ
		|	РегистрСведений.КР_ОшибкиПоискаДанныхИнтеграции КАК КР_ОшибкиПоискаДанныхИнтеграции
		|ГДЕ
		|	ДОБАВИТЬКДАТЕ(КР_ОшибкиПоискаДанныхИнтеграции.ПериодЗаписи, ДЕНЬ, &ЛимитВДняхХраненияОшибокПоискаДанных) <= &ТекущаяДатаСеанса";
	
	Запрос.УстановитьПараметр("ЛимитВДняхХраненияОшибокПоискаДанных", НастройкиБазы.ЛимитВДняхХраненияОшибокПоискаДанных);
	Запрос.УстановитьПараметр("ТекущаяДатаСеанса", ТекущаяДатаСеанса());
	
	РезультатЗапроса = Запрос.Выполнить();
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл		
        Набор = РегистрыСведений.КР_ОшибкиПоискаДанныхИнтеграции.СоздатьНаборЗаписей();
		Набор.Отбор.ХэшИдентификаторЗаписи.Установить(ВыборкаДетальныеЗаписи.ХэшИдентификаторЗаписи);
		Набор.Записать(Истина);		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьМассивВходящихСообщений(МассивКлючей, 
	СтатусыОбработки = Неопределено, ИдентификаторГруппировкиДанных = Неопределено) Экспорт 
	
	// Инициализация переменного окружения
	ОбщиеПараметрыЗагрузки = КР_ОбменRabbitОбщиеМеханизмыПовтИсп.ПолучитьНастройкиЗагрузкиОбъектов();
	ВходящиеСообщения = РегистрыСведений.КР_ВходящиеСообщения; 
	
	Если СтатусыОбработки = Неопределено Тогда
		СтатусыОбработки = Новый Массив;
		СтатусыОбработки.Добавить(Перечисления.КР_СостоянияСообщенийОбмена.Зарегистрировано);
		СтатусыОбработки.Добавить(Перечисления.КР_СостоянияСообщенийОбмена.КОбработке);
	КонецЕсли;
	
	// Удалим накопленные сеансовые сообщения
	ПолучитьСообщенияПользователю(Истина);
	
	Для Каждого КлючСообщения Из МассивКлючей Цикл
		
		СтруктураСообщения = Неопределено;
		Если Не ПолучитьВходящееСообщениеДляОбработки(
			СтруктураСообщения, КлючСообщения, СтатусыОбработки, ИдентификаторГруппировкиДанных) Тогда
			Продолжить;
		КонецЕсли;
		
		// Оценка производительности
		ВремяНачала = ОценкаПроизводительности.НачатьЗамерВремени();
		КлючеваяОперация = "RabbitMQ.ОбработкаВходящихСообщений." + СтруктураСообщения.ТипДанных; 
		// Оценка производительности
		
		// Сначала выполняем поиск только по типу данных.
		СтруктураПоиска = Новый Структура("ТипДанных", СтруктураСообщения.ТипДанных);
		НайденныеСтроки = ОбщиеПараметрыЗагрузки.НайтиСтроки(СтруктураПоиска);
		
		// просто маркер, что выбранное сообщение попало под правила, имеющиеся в базе
		ВыполненоОбработчиков = 0;
		
		Для Каждого СтрокаПравила Из НайденныеСтроки Цикл
			
			// затем сверяем, если в правилах указан отправитель или очередь, тогда 
			// они должны совпадать со значениями из выборки
			// если не указаны, считаем, что правило подходит для разбора данного сообщения.			
			Если ЗначениеЗаполнено(СтрокаПравила.Отправитель) И 
				СтрокаПравила.Отправитель <> СтруктураСообщения.Отправитель Тогда
				Продолжить;
			КонецЕсли;			
			Если ЗначениеЗаполнено(СтрокаПравила.ОчередьОбмена) И 
				СтрокаПравила.ОчередьОбмена <> СтруктураСообщения.ОчередьОбмена Тогда
				Продолжить;
			КонецЕсли;
			
			// Получаем правило загрузки
			ПравилоЗагрузки = СтрокаПравила.ПравилоЗагрузки;
			Если Не ЗначениеЗаполнено(ПравилоЗагрузки) Тогда
				Продолжить;
			КонецЕсли;				
			
			ВыполненоОбработчиков = ВыполненоОбработчиков + 1;			
			
			Если Не ВыполнитьСерилизациюТелаСообщения(СтрокаПравила, СтруктураСообщения) Тогда 
				Прервать; // ???				
			КонецЕсли;	
			
			ТекстЗадачиЗагрузки = ПравилоЗагрузки + "(СтруктураСообщения);";			
			
			ТекстСообщения = НСтр("ru='Обработка сообщения по правилу: %1'");
			ТекстСообщения = СтрШаблон(ТекстСообщения, ПравилоЗагрузки);
			ДобавитьЗаписьВЛог(СтруктураСообщения, ТекстСообщения);
			
			Попытка
				Выполнить ТекстЗадачиЗагрузки;
				
				Если СтруктураСообщения.ЕстьОшибка Тогда
					ТекстСообщения = НСтр("ru='Алгоритм преобразования сообщения вернул ошибку. 
					|Алгоритм: %1
					|ТипДанных: %2
					|Отправитель: %3
					|ОчередьОбмена: %4'");
					ТекстСообщения = СтрШаблон(ТекстСообщения, 
					ТекстЗадачиЗагрузки,
					СтрокаПравила.ТипДанных,
					СтрокаПравила.Отправитель,
					СтрокаПравила.ОчередьОбмена);					
					
					ДобавитьЗаписьВЛог(СтруктураСообщения, ТекстСообщения, ТипЗаписиВЛог_Ошибка());				
					
				Иначе
					ТекстСообщения = НСтр("ru='Успешно выполнен алгоритм преобразования сообщения: %1'");
					ТекстСообщения = СтрШаблон(ТекстСообщения, ТекстЗадачиЗагрузки);
					ДобавитьЗаписьВЛог(СтруктураСообщения, ТекстСообщения);
				КонецЕсли;
				
				ДобавитьВЛогСообщенияПользователю(СтруктураСообщения);
				
			Исключение
				
				ТекстСообщения = НСтр("ru='Исключительная ошибка итерации обработки сообщения обмена:
				|%1'");
				ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ДобавитьЗаписьВЛог(СтруктураСообщения, ТекстСообщения, ТипЗаписиВЛог_Ошибка());	
				
				ДобавитьВЛогСообщенияПользователю(СтруктураСообщения);
				
				// Оценка производительности
				ОценкаПроизводительности.ЗакончитьЗамерВремени(КлючеваяОперация, ВремяНачала, ВыполненоОбработчиков, , Истина); 
				// Оценка производительности
				
				Прервать;
				
			КонецПопытки;			
			
		КонецЦикла;		
		
		Если ВыполненоОбработчиков = 0 Тогда
			ТекстСообщения = НСтр("ru='Не обнаружено правило для разбора данного сообщения'");
			ДобавитьЗаписьВЛог(СтруктураСообщения, ТекстСообщения, ТипЗаписиВЛог_Ошибка());	
		КонецЕсли;		
		
		ЗарегистрироватьОбработкуВходящегоСообщения(СтруктураСообщения);
		
		// Оценка производительности
		ОценкаПроизводительности.ЗакончитьЗамерВремени(КлючеваяОперация, ВремяНачала, ВыполненоОбработчиков); 
		// Оценка производительности
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Возвращает структуру Исходящего сообщения
//
// Возвращаемое значение:
//   Структура  - Данные об Исходящем сообщении
//
Функция ПолучитьСтруктуруСообщения() Экспорт

	СтруктураСообщения = Новый Структура;
	СтруктураСообщения.Вставить("Отправитель", КР_ОбменRabbitОбщиеМеханизмыПовтИсп.ПолучитьТекущуюИнформационнуюБазу().Ссылка);
	СтруктураСообщения.Вставить("КлючСообщения", Строка(Новый УникальныйИдентификатор));
	СтруктураСообщения.Вставить("ТипДанных", "");
	СтруктураСообщения.Вставить("Маршрутизация", "");
	СтруктураСообщения.Вставить("ТелоСообщения", "");
	СтруктураСообщения.Вставить("ЭтоУдаление", Ложь);
	СтруктураСообщения.Вставить("Логирование", "");
	СтруктураСообщения.Вставить("МоментРегистрации", ТекущаяУниверсальнаяДатаВМиллисекундах());
	СтруктураСообщения.Вставить("ДатаРегистрации", ТекущаяДатаСеанса());
	СтруктураСообщения.Вставить("ЕстьОшибка", Ложь);
	СтруктураСообщения.Вставить("УточненноеСостояние", Неопределено);
	СтруктураСообщения.Вставить("СсылкиНаОбъекты", Новый Массив);
	СтруктураСообщения.Вставить("СобытиеЖурналаРегистрации", "RabbitMQ.ИсходящееСообщение");
	
	Возврат СтруктураСообщения;
	
КонецФункции

// Возвращает структуру Входящего сообщения
//
// Возвращаемое значение:
//   Структура  - Данные об Входящем сообщении
//
Функция ПолучитьСтруктуруВходящегоСообщения()

	СтруктураСообщения = Новый Структура;
	// можем найти по наименованию и создать
	// но для поиска обязательно использовать повт.исп
	// можем искать и создавать базу в момент загрузки, но кажется, что лучше там меньше времени на это использовать
	СтруктураСообщения.Вставить("Отправитель", ""); 
	СтруктураСообщения.Вставить("КлючСообщения", "");
	СтруктураСообщения.Вставить("ТипДанных", "");
	СтруктураСообщения.Вставить("ОчередьОбмена", "");
	СтруктураСообщения.Вставить("ТелоСообщения", "");
	// << 25.12.2023 Петухов А.В., Фактор, #3553
	// Используется при чтении данных регистра
	СтруктураСообщения.Вставить("ТелоСообщенияСжатое", Неопределено);
	// >> 25.12.2023 Петухов А.В., Фактор, #3553
	//СтруктураСообщения.Вставить("ДанныеXDTO", Неопределено);
	СтруктураСообщения.Вставить("Логирование", "");
	СтруктураСообщения.Вставить("ЕстьОшибка", Ложь);    
	СтруктураСообщения.Вставить("УточненноеСостояние");
	СтруктураСообщения.Вставить("СсылкиНаОбъекты", Новый Массив);
	СтруктураСообщения.Вставить("СобытиеЖурналаРегистрации", "RabbitMQ.ВходящееСообщение");
	// << 28.03.2024 Петухов А.В., Фактор, #3915
	СтруктураСообщения.Вставить("КоличествоПопытокОбработки", 0);
	// >> 28.03.2024 Петухов А.В., Фактор, #3915
	
	// A2105505-1430
	СтруктураСообщения.Вставить("ОшибкиПоискаДанныхИнтеграции", Новый Массив); 
	//
	
	// A2105505-1515
	СтруктураСообщения.Вставить("МоментРегистрации"); 
	СтруктураСообщения.Вставить("ДатаРегистрации"); 
	//
		
	Возврат СтруктураСообщения; 
	
КонецФункции

// Переносит все отправленные исходящие сообщения и обработанные входящие сообщения в РС "КР_АрхивСообщений"
//	и выполняет удаление их из регистров очередей "КР_ВходящиеСообщения" и "КР_ИсходящиеСообщения"
//
// Параметры:
//  КлючСообщения  - Строка - Перенос только конкретного выбранного сообщения 
//			используется с формы обработки "КР_МеханизмОбмена"
//  ВходящееСообщение  - Булево - указание, какой вид сообщений будет обрабатываться 
//
Процедура ПеренестиСообщенияВАрхив(КлючСообщения = "", ВходящееСообщение = Ложь) Экспорт

	Если ЗначениеЗаполнено(КлючСообщения) Тогда
		ДоступныеСостояния = Неопределено;
		ТекстЗапроса = 
			"ВЫБРАТЬ
			|	КР_ВходящиеСообщения.КлючСообщения КАК КлючСообщения,
			|	""КР_ВходящиеСообщения"" КАК ИмяЗаписи
			|ИЗ
			|	РегистрСведений.КР_ВходящиеСообщения КАК КР_ВходящиеСообщения
			|ГДЕ
			|	КР_ВходящиеСообщения.КлючСообщения = &КлючСообщения
			|	И &ВходящееСообщение
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|
			|ВЫБРАТЬ
			|	КР_ИсходящиеСообщения.КлючСообщения,
			|	""КР_ИсходящиеСообщения""
			|ИЗ
			|	РегистрСведений.КР_ИсходящиеСообщения КАК КР_ИсходящиеСообщения
			|ГДЕ
			|	КР_ИсходящиеСообщения.КлючСообщения = &КлючСообщения
			|	И НЕ &ВходящееСообщение";
	Иначе	
		ТекстЗапроса = 
			"ВЫБРАТЬ
			|	КР_ВходящиеСообщения.КлючСообщения КАК КлючСообщения,
			|	""КР_ВходящиеСообщения"" КАК ИмяЗаписи
			|ИЗ
			|	РегистрСведений.КР_ВходящиеСообщения КАК КР_ВходящиеСообщения
			|ГДЕ
			|	КР_ВходящиеСообщения.Состояние В (
			|		ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Обработано),
			|		ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.УстаревшиеДанные)
			|	)
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|
			|ВЫБРАТЬ
			|	КР_ИсходящиеСообщения.КлючСообщения,
			|	""КР_ИсходящиеСообщения""
			|ИЗ
			|	РегистрСведений.КР_ИсходящиеСообщения КАК КР_ИсходящиеСообщения
			|ГДЕ
			|	КР_ИсходящиеСообщения.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Отправлено)";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса; 
	Запрос.УстановитьПараметр("КлючСообщения", КлючСообщения);
	Запрос.УстановитьПараметр("ВходящееСообщение", ВходящееСообщение);
	РезультатЗапроса = Запрос.Выполнить();	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		
        НачатьТранзакцию();
		Попытка
			
			ПространствоБлокировки = "РегистрСведений." + ВыборкаДетальныеЗаписи.ИмяЗаписи;
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
			ЭлементБлокировки.УстановитьЗначение("КлючСообщения", ВыборкаДетальныеЗаписи.КлючСообщения);
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			Блокировка.Заблокировать();
			
			МенеджерЗаписи = РегистрыСведений[ВыборкаДетальныеЗаписи.ИмяЗаписи].СоздатьМенеджерЗаписи();
			МенеджерЗаписи.КлючСообщения = ВыборкаДетальныеЗаписи.КлючСообщения;
			МенеджерЗаписи.Прочитать();
						
			МенеджерАрхива = РегистрыСведений.КР_АрхивСообщений.СоздатьМенеджерЗаписи();
			МенеджерАрхива.КлючСообщения = МенеджерЗаписи.КлючСообщения;
			
			Если ТипЗнч(МенеджерЗаписи) = Тип("РегистрСведенийМенеджерЗаписи.КР_ИсходящиеСообщения") Тогда
				МенеджерАрхива.ТипСообщения = Перечисления.КР_ТипыСообщенийОбмена.ИсходящееСообщение;	
			Иначе
				МенеджерАрхива.ТипСообщения = Перечисления.КР_ТипыСообщенийОбмена.ВходящееСообщение;
			КонецЕсли;
			
			ЗаполнитьЗначенияСвойств(МенеджерАрхива, МенеджерЗаписи);
			МенеджерАрхива.ДатаАрхивирования = ТекущаяДатаСеанса();
			
			МенеджерАрхива.Записать(Истина);
			МенеджерЗаписи.Удалить();
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			
			ТекстСообщения = НСтр("ru='Исключительная ошибка запуска архивирования сообщений:
				|%1'");
			ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьЖурналаРегистрации("RabbitMQ.АрхивированиеСообщений",УровеньЖурналаРегистрации.Ошибка,,,ТекстСообщения);
			
			Возврат;
			
		КонецПопытки;
		
	КонецЦикла;	
	
КонецПроцедуры

Процедура ВосстановитьСообщениеИзАрхива(КлючСообщения) Экспорт

	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	КР_АрхивСообщений.КлючСообщения КАК КлючСообщения,
		|	КР_АрхивСообщений.ТипСообщения КАК ТипСообщения,
		|	ВЫБОР
		|		КОГДА КР_АрхивСообщений.ТипСообщения = ЗНАЧЕНИЕ(Перечисление.КР_ТипыСообщенийОбмена.ВходящееСообщение)
		|			ТОГДА ""КР_ВходящиеСообщения""
		|		ИНАЧЕ ""КР_ИсходящиеСообщения""
		|	КОНЕЦ КАК ИмяЗаписи
		|ИЗ
		|	РегистрСведений.КР_АрхивСообщений КАК КР_АрхивСообщений
		|ГДЕ
		|	КР_АрхивСообщений.КлючСообщения = &КлючСообщения";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса; 
	Запрос.УстановитьПараметр("КлючСообщения", КлючСообщения);
	РезультатЗапроса = Запрос.Выполнить();	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		
        НачатьТранзакцию();
		Попытка
			
			ПространствоБлокировки = "РегистрСведений.КР_АрхивСообщений";
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
			ЭлементБлокировки.УстановитьЗначение("КлючСообщения", ВыборкаДетальныеЗаписи.КлючСообщения);
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			Блокировка.Заблокировать();
			
			МенеджерАрхива = РегистрыСведений.КР_АрхивСообщений.СоздатьМенеджерЗаписи();
			МенеджерАрхива.КлючСообщения = ВыборкаДетальныеЗаписи.КлючСообщения;
			МенеджерАрхива.ТипСообщения = ВыборкаДетальныеЗаписи.ТипСообщения;
			МенеджерАрхива.Прочитать();
			
			МенеджерЗаписи = РегистрыСведений[ВыборкаДетальныеЗаписи.ИмяЗаписи].СоздатьМенеджерЗаписи();
			МенеджерЗаписи.КлючСообщения = ВыборкаДетальныеЗаписи.КлючСообщения;
									
			ЗаполнитьЗначенияСвойств(МенеджерЗаписи, МенеджерАрхива);
			МенеджерЗаписи.Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Зарегистрировано;
			
			МенеджерЗаписи.Записать(Истина);
			МенеджерАрхива.Удалить();
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			
			ТекстСообщения = НСтр("ru='Исключительная ошибка запуска архивирования сообщений:
				|%1'");
			ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьЖурналаРегистрации("RabbitMQ.АрхивированиеСообщений",УровеньЖурналаРегистрации.Ошибка,,,ТекстСообщения);
			
			Возврат;
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОстановитьОбработкуПоТаймауту(НастройкиБазы)
	
	// A2105505-1431
	// Получаем зависшие сообщения Обрабатывается 
	//	и если время которое отведено на обработку истекло, то установим статус ошибки  
	ЛимитВМинутахВСтатусеОбрабатывается = НастройкиБазы.ЛимитВМинутахВСтатусеОбрабатывается;  
	Если ЛимитВМинутахВСтатусеОбрабатывается = 0 Тогда
		Возврат;		
	КонецЕсли;
	
	ВходящиеСообщения = РегистрыСведений.КР_ВходящиеСообщения;	
	
	
		Запрос = Новый Запрос;
		Запрос.Текст = 
			"ВЫБРАТЬ
			|	КР_ВходящиеСообщения.КлючСообщения КАК КлючСообщения
			|ИЗ
			|	РегистрСведений.КР_ВходящиеСообщения КАК КР_ВходящиеСообщения
			|ГДЕ
			|	КР_ВходящиеСообщения.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Обрабатывается)
			|	И РАЗНОСТЬДАТ(КР_ВходящиеСообщения.ДатаИзмененияЗаписи, &ТекущаяДата, МИНУТА) 
			|		> &ЛимитВМинутахВСтатусеОбрабатывается";
		
		Запрос.УстановитьПараметр("ЛимитВМинутахВСтатусеОбрабатывается", ЛимитВМинутахВСтатусеОбрабатывается);
		Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());  
		РезультатЗапроса = Запрос.Выполнить();
		Если РезультатЗапроса.Пустой() Тогда
			Возврат;
		КонецЕсли;
		
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл 
			
			Попытка
				НачатьТранзакцию();
				
				Блокировка = Новый БлокировкаДанных;
				ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КР_ВходящиеСообщения");
				ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
				ЭлементБлокировки.УстановитьЗначение("КлючСообщения", ВыборкаДетальныеЗаписи.КлючСообщения);
				Блокировка.Заблокировать();
				
				Запись = ВходящиеСообщения.СоздатьМенеджерЗаписи();
				Запись.КлючСообщения = ВыборкаДетальныеЗаписи.КлючСообщения;			
				Запись.Прочитать();
				Запись.Состояние = Перечисления.КР_СостоянияСообщенийОбмена.ТаймаутОбработки;
				Запись.КоличествоПопытокОбработки = Запись.КоличествоПопытокОбработки + 1;
				Запись.Логирование = НСтр("ru = 'Превышен лимит времени нахождения в статусе ""Обрабатывается""'");
				
				Запись.Записать(Истина);
				
				ЗафиксироватьТранзакцию();
				
			Исключение
				ОтменитьТранзакцию();
				ТекстСообщения = НСтр("ru='Исключительная ошибка итерации контроля лимита времени обработки сообщений:
					|%1'");
				ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ЗаписьЖурналаРегистрации("RabbitMQ.ОбработкаСообщений",УровеньЖурналаРегистрации.Ошибка,,,ТекстСообщения);
				Продолжить;
			КонецПопытки;
			
		КонецЦикла;			
	
КонецПроцедуры	

Процедура УстановитьИдентификаторГруппировкиДанных(НастройкиБазы)
	
	// Условно считаем, что в одном моменте времени может быть только одно задание разбора сообщений
	// Если будут проблемы, ввести блокировку через служебный регистр
	
	// В рамках этой процедуры накладываем транзакцию на все записи РС Входящих сообщений, 
	// чтобы гарантировать только одну итерацию обработки сообщения
	// обрабатывать будем по одной записи за раз
	// чтобы не держать транзакцию на время всей обработки сообщения, 
	// поменяем статус у записи в РС и зафиксируем таранзакцию
	
	// Инициализация переменного окружения
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КР_ВходящиеСообщения.КлючСообщения КАК КлючСообщения
		|ИЗ
		|	РегистрСведений.КР_ВходящиеСообщения КАК КР_ВходящиеСообщения
		|ГДЕ
		|	КР_ВходящиеСообщения.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Зарегистрировано)";
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
    ТаблицаКлючей = РезультатЗапроса.Выгрузить();

	ВходящиеСообщения = РегистрыСведений.КР_ВходящиеСообщения; 
	Попытка
		НачатьТранзакцию();		
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КР_ВходящиеСообщения");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		ЭлементБлокировки.ИсточникДанных = ТаблицаКлючей;
		ЭлементБлокировки.ИспользоватьИзИсточникаДанных("КлючСообщения", "КлючСообщения");
		Блокировка.Заблокировать();
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
			"ВЫБРАТЬ
			|	КР_ВходящиеСообщения.Отправитель КАК Отправитель,
			|	КР_ВходящиеСообщения.ОчередьОбмена КАК ОчередьОбмена,
			|	КР_ВходящиеСообщения.КлючСообщения КАК КлючСообщения,
			|	КР_ВходящиеСообщения.ТипДанных КАК ТипДанных
			|ИЗ
			|	РегистрСведений.КР_ВходящиеСообщения КАК КР_ВходящиеСообщения
			|ГДЕ
			|	КР_ВходящиеСообщения.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Зарегистрировано)
			|
			|УПОРЯДОЧИТЬ ПО
			|	КР_ВходящиеСообщения.ДатаРегистрации,
			|	КР_ВходящиеСообщения.МоментРегистрации
			|ИТОГИ ПО
			|	Отправитель,
			|	ОчередьОбмена";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		ВыборкаОтправитель = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		Пока ВыборкаОтправитель.Следующий() Цикл		
			ВыборкаОчередьОбмена = ВыборкаОтправитель.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			Пока ВыборкаОчередьОбмена.Следующий() Цикл
				ВыборкаДетальныеЗаписи = ВыборкаОчередьОбмена.Выбрать();
				
				ИдентификаторГруппировкиДанных = Неопределено;
				ТипДанных = Неопределено;
				ИтераторГруппы = 0;
				
				Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
					
					// Обрабатываем полученную запись
					Если ТипДанных <> ВыборкаДетальныеЗаписи.ТипДанных Тогда 
						ИдентификаторГруппировкиДанных = ТекущаяУниверсальнаяДатаВМиллисекундах();	
						ИтераторГруппы = ИтераторГруппы + 1;
						ИдентификаторГруппировкиДанных = ИдентификаторГруппировкиДанных * 1000 + ИтераторГруппы; 
						ТипДанных = ВыборкаДетальныеЗаписи.ТипДанных; 
					КонецЕсли;	
					
					Запись = ВходящиеСообщения.СоздатьМенеджерЗаписи();
					Запись.КлючСообщения = ВыборкаДетальныеЗаписи.КлючСообщения;			
					Запись.Прочитать();
					Запись.Состояние = Перечисления.КР_СостоянияСообщенийОбмена.КОбработке;
					Запись.ИдентификаторГруппировкиДанных = ИдентификаторГруппировкиДанных;
					
					Запись.Записать(Истина);
					
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;		
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ТекстСообщения = НСтр("ru='Исключительная ошибка итерации выбора сообщений к обработке:
			|%1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации("RabbitMQ.ОбработкаСообщений",УровеньЖурналаРегистрации.Ошибка,,,ТекстСообщения);
		Возврат;
		
	КонецПопытки;
	
КонецПроцедуры

Функция ПолучитьДанныеДляОбработкиФоновымиЗаданиямиСГруппировкой(ДанныеДляОбработки, НастройкиБазы)

	ДанныеДляОбработки = Новый Массив;
	
	// Выбираем данные КОбработке с группировками и сортировкой по группе....  
	//	но только если нет записей со статусом Обрабатывается
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Т.ОчередьОбмена КАК ОчередьОбмена,
	|	Т.Отправитель КАК Отправитель
	|ПОМЕСТИТЬ ЕстьОбрабатываемыеДанные
	|ИЗ
	|	РегистрСведений.КР_ВходящиеСообщения КАК Т
	|ГДЕ
	|	Т.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Обрабатывается)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Т.ОчередьОбмена КАК ОчередьОбмена,
	|	Т.Отправитель КАК Отправитель,
	|	Т.ТипДанных КАК ТипДанных,
	|	ВЫБОР
	|		КОГДА &БезИдентификатораГруппировки
	|			ТОГДА 0
	|		ИНАЧЕ Т.ИдентификаторГруппировкиДанных
	|	КОНЕЦ КАК ИдентификаторГруппировкиДанных,
	|	Т.КлючСообщения КАК КлючСообщения
	|ИЗ
	|	РегистрСведений.КР_ВходящиеСообщения КАК Т
	|		ЛЕВОЕ СОЕДИНЕНИЕ ЕстьОбрабатываемыеДанные КАК ЕстьОбрабатываемыеДанные
	|		ПО Т.ОчередьОбмена = ЕстьОбрабатываемыеДанные.ОчередьОбмена
	|			И Т.Отправитель = ЕстьОбрабатываемыеДанные.Отправитель
	|ГДЕ
	|	Т.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.КОбработке)
	|	И ЕстьОбрабатываемыеДанные.ОчередьОбмена ЕСТЬ NULL
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИдентификаторГруппировкиДанных,
	|	Т.ДатаРегистрации,
	|	Т.МоментРегистрации
	|ИТОГИ
	|	МАКСИМУМ(ТипДанных)
	|ПО
	|	ОчередьОбмена,
	|	Отправитель,
	|	ИдентификаторГруппировкиДанных"); 
	
	
	Запрос.УстановитьПараметр("БезИдентификатораГруппировки", НастройкиБазы.ТипыДанныхПараллельнойОбработки.Количество() = 0);
	РезультатЗапроса = Запрос.Выполнить(); 
	// Нас интересует только первая группировка в каждой паре ОчередьОбмена + Отправитель
	// Именно по ней будут запускаться фоновые задания      
	
	ВыборкаОчередей = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаОчередей.Следующий() Цикл 
		ВыборкаОтправителей = ВыборкаОчередей.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам); 
		Пока ВыборкаОтправителей.Следующий() Цикл
		
			ПерваяГруппировка = ВыборкаОтправителей.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			Если Не ПерваяГруппировка.Следующий() Тогда 
				Возврат Ложь;
			КонецЕсли;
	
			ТипДанных = ПерваяГруппировка.ТипДанных;  

			ВыборкаДетальныеЗаписи = ПерваяГруппировка.Выбрать(); 
			МаксКоличествоПотоков = Макс(1, НастройкиБазы.КоличествоПотоковПараллельнойОбработки);     
			МаксКоличествоЗаписейВПотоке = ВыборкаДетальныеЗаписи.Количество();
			
			Если НастройкиБазы.ТипыДанныхПараллельнойОбработки.Найти(ТипДанных) <> Неопределено Тогда 
				МаксКоличествоЗаписейВПотоке = Окр(МаксКоличествоЗаписейВПотоке / МаксКоличествоПотоков + 0.5, 0,
					РежимОкругления.Окр15как10);   
			КонецЕсли;	

			МассивКлючей = Новый Массив;	
			ПакетДанных = Новый Структура;
			ПакетДанных.Вставить("ТипДанных", ТипДанных);
			ПакетДанных.Вставить("ОчередьОбмена", ПерваяГруппировка.ОчередьОбмена);
			ПакетДанных.Вставить("Отправитель", ПерваяГруппировка.Отправитель);
			ПакетДанных.Вставить("ИдентификаторГруппировкиДанных", ПерваяГруппировка.ИдентификаторГруппировкиДанных);
			ПакетДанных.Вставить("МассивКлючей", МассивКлючей);
			Пока ВыборкаДетальныеЗаписи.Следующий() Цикл 
				
				Если МассивКлючей.Количество() = МаксКоличествоЗаписейВПотоке Тогда 

					ДанныеДляОбработки.Добавить(ПакетДанных);

					МассивКлючей = Новый Массив;
					ПакетДанных = Новый Структура;
					ПакетДанных.Вставить("ОчередьОбмена", ПерваяГруппировка.ОчередьОбмена);
					ПакетДанных.Вставить("Отправитель", ПерваяГруппировка.Отправитель);
					ПакетДанных.Вставить("ТипДанных", ТипДанных);
					ПакетДанных.Вставить("ИдентификаторГруппировкиДанных", ПерваяГруппировка.ИдентификаторГруппировкиДанных);
					ПакетДанных.Вставить("МассивКлючей", МассивКлючей);

				КонецЕсли;	          
				
				МассивКлючей.Добавить(ВыборкаДетальныеЗаписи.КлючСообщения);
				
			КонецЦикла;	              
			
			ДанныеДляОбработки.Добавить(ПакетДанных);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ПолучитьДанныеДляОбработкиФоновымиЗаданиямиБезГруппировки(ДанныеДляОбработки, НастройкиБазы)

	ДанныеДляОбработки = Новый Соответствие;
	
	// Выбираем данные в состоянии Зарегировано
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Т.ИдентификаторГруппировкиДанных) КАК КоличествоЗапущенныхПотоков
		|ИЗ
		|	РегистрСведений.КР_ВходящиеСообщения КАК Т
		|ГДЕ
		|	Т.Состояние В (ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Обрабатывается), ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.КОбработке))"; 
	
	РезультатЗапроса = Запрос.Выполнить();
	
	// Получаем (опосредованно) количество запущенных потоков
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать(); 
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		КоличествоЗапущенныхПотоков = ВыборкаДетальныеЗаписи.КоличествоЗапущенныхПотоков;	
	Иначе
		КоличествоЗапущенныхПотоков = 0;	
	КонецЕсли;
	
	МаксКоличествоПотоков = Макс(1, НастройкиБазы.КоличествоПотоковПараллельнойОбработки); 
	МаксКоличествоПотоков = МаксКоличествоПотоков - КоличествоЗапущенныхПотоков;
	Если МаксКоличествоПотоков < 1 Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1000
		|	Т.КлючСообщения КАК КлючСообщения
		|ИЗ
		|	РегистрСведений.КР_ВходящиеСообщения КАК Т
		|ГДЕ
		|	Т.Состояние = ЗНАЧЕНИЕ(Перечисление.КР_СостоянияСообщенийОбмена.Зарегистрировано)
		|
		|УПОРЯДОЧИТЬ ПО
		|	Т.ДатаРегистрации,
		|	Т.МоментРегистрации";
	РезультатЗапроса = Запрос.Выполнить();	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать(); 
	МаксКоличествоЗаписейВПотоке = ВыборкаДетальныеЗаписи.Количество();
	
	МаксКоличествоЗаписейВПотоке = Окр(МаксКоличествоЗаписейВПотоке / МаксКоличествоПотоков + 0.5, 0,
		РежимОкругления.Окр15как10);		
		
	МассивКлючей = Новый Массив;
	
	ИтераторФоновыхЗаданий = 1;	
	ИдентификаторГруппировкиДанных = ТекущаяУниверсальнаяДатаВМиллисекундах(); // малая детализация
	ИдентификаторГруппировкиДанных = ИдентификаторГруппировкиДанных * 1000 + ИтераторФоновыхЗаданий;
	
	Попытка
		НачатьТранзакцию();		
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КР_ВходящиеСообщения");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		ЭлементБлокировки.ИсточникДанных = РезультатЗапроса;
		ЭлементБлокировки.ИспользоватьИзИсточникаДанных("КлючСообщения", "КлючСообщения");
		Блокировка.Заблокировать();
		
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл 
			
			Если МассивКлючей.Количество() = МаксКоличествоЗаписейВПотоке Тогда 
				
				ДанныеДляОбработки.Вставить(ИдентификаторГруппировкиДанных, МассивКлючей);
				
				ИтераторФоновыхЗаданий = ИтераторФоновыхЗаданий + 1;	
				ИдентификаторГруппировкиДанных = ТекущаяУниверсальнаяДатаВМиллисекундах(); // малая детализация
				ИдентификаторГруппировкиДанных = ИдентификаторГруппировкиДанных * 1000 + ИтераторФоновыхЗаданий;
				
				МассивКлючей = Новый Массив;
				
			КонецЕсли;	          
			
			МассивКлючей.Добавить(ВыборкаДетальныеЗаписи.КлючСообщения);
			
			// установить статусную отметку на сообщение, чтобы оно больше не выбиралось в запросе
			Запись = РегистрыСведений.КР_ВходящиеСообщения.СоздатьМенеджерЗаписи();
			Запись.КлючСообщения = ВыборкаДетальныеЗаписи.КлючСообщения;			
			Запись.Прочитать();
			Запись.Состояние = Перечисления.КР_СостоянияСообщенийОбмена.КОбработке;		
			Запись.ИдентификаторГруппировкиДанных = ИдентификаторГруппировкиДанных;
			Запись.Записать(Истина);
			
		КонецЦикла;	
		
		Если МассивКлючей.Количество() > 0 Тогда
			ДанныеДляОбработки.Вставить(ИдентификаторГруппировкиДанных, МассивКлючей);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
		Возврат Истина;
		
	Исключение
		ОтменитьТранзакцию();

		ТекстСообщения = НСтр("ru='Ошибка подготовки данных для обработки без группировки по типам:
			|%1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации("RabbitMQ.ОбработкаСообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
		
		ДанныеДляОбработки = Неопределено;
		Возврат Ложь;
		
	КонецПопытки;	
	
КонецФункции

Функция ВыполнитьСерилизациюТелаСообщения(СтрокаПравила, СообщениеОбмена)
	
	// Если алгоритм не определен, то используем алгоритм по умолчанию  
	АлгоритмСериализации = ?(СтрокаПравила.АлгоритмСериализации = Неопределено, "JSONВДанныеXDTO", 
		СтрокаПравила.АлгоритмСериализации); 

// << 25.12.2023 Петухов А.В., Фактор, #3553
	// Распаковывать сообщение непосредственно при обработке.
	Если ПустаяСтрока(СообщениеОбмена.ТелоСообщения) Тогда
		РаспакованноеСообщение = СообщениеОбмена.ТелоСообщенияСжатое.Получить();
		Если РаспакованноеСообщение <> Неопределено Тогда
			СообщениеОбмена.ТелоСообщения = РаспакованноеСообщение;
		КонецЕсли;
	КонецЕсли;
// >> 25.12.2023 Петухов А.В., Фактор, #3553
		
	Попытка    
		
		// Сериализуем тело сообщения по выбранному алгоритму
		// Удаляем тело при успешном выполнении.
		Данные = Неопределено;
		Если АлгоритмСериализации = "JSONВДанныеXDTO" Тогда 
			
			Данные = КР_ФункцииРаботыJSON.ДесериализоватьXDTOИзJSON(СообщениеОбмена.ТелоСообщения);	 
			
		ИначеЕсли АлгоритмСериализации = "XMLВДанныеXDTO" Тогда 
			
			Данные = КР_ФункцииРаботыXML.ДесериализоватьXDTOИзXML(СообщениеОбмена.ТелоСообщения);	 
			
		ИначеЕсли АлгоритмСериализации = "JSONВДанныеСтруктура" Тогда 
			
			ЧтениеJSON = Новый ЧтениеJSON;      
			ЧтениеJSON.УстановитьСтроку(СообщениеОбмена.ТелоСообщения);
			Данные = ПрочитатьJSON(ЧтениеJSON);     
			
		ИначеЕсли АлгоритмСериализации = "JSONВДанныеСоответствие" Тогда 
			
			ЧтениеJSON = Новый ЧтениеJSON;      
			ЧтениеJSON.УстановитьСтроку(СообщениеОбмена.ТелоСообщения);
			Данные = ПрочитатьJSON(ЧтениеJSON, Истина);
			
		ИначеЕсли АлгоритмСериализации = "НеПрименять" Тогда 
			// Ничего не делаем
		Иначе
			
			ТекстСообщения = НСтр("ru = 'Не известный вариант алгоритма сериализации %1 (ключ сообщения %2). "
				+ " Возможные варианты НеПрименять/JSONВДанныеXDTO/XMLВДанныеXDTO/JSONВДанныеСтруктура/JSONВДанныеСоответствие'");   
			ТекстСообщения = СтрШаблон(ТекстСообщения, АлгоритмСериализации, СообщениеОбмена.КлючСообщения);
				
			ТипЗаписиВЛог = КР_ОбменRabbitОбработкаСообщенийОбмена.ТипЗаписиВЛог_ОшибкаСериализации();
			КР_ОбменRabbitОбработкаСообщенийОбмена.ДобавитьЗаписьВЛог(СообщениеОбмена, ТекстСообщения, ТипЗаписиВЛог);
				
			Возврат Ложь;
			
		КонецЕсли;	
		
		Если Данные <> Неопределено Тогда 
			СообщениеОбмена.Вставить("Данные", Данные);    
			СообщениеОбмена.Удалить("ТелоСообщения");   
// << 25.12.2023 Петухов А.В., Фактор, #3553
			// Необязательно. Действует как страховка от повторной обработки.
			СообщениеОбмена.Удалить("ТелоСообщенияСжатое");   
// >> 25.12.2023 Петухов А.В., Фактор, #3553
		КонецЕсли;	
		
	Исключение
			
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		ТекстСообщения = НСтр("ru = 'Ошибка сериализации сообщения по алгоритму ""%1"" (ключ сообщения %2): %3'");   
		ТекстСообщения = СтрШаблон(ТекстСообщения, АлгоритмСериализации, СообщениеОбмена.КлючСообщения, ОписаниеОшибки);
			
		ТипЗаписиВЛог = КР_ОбменRabbitОбработкаСообщенийОбмена.ТипЗаписиВЛог_ОшибкаСериализации();
		КР_ОбменRabbitОбработкаСообщенийОбмена.ДобавитьЗаписьВЛог(СообщениеОбмена, ТекстСообщения, ТипЗаписиВЛог);
			
		Возврат Ложь;
		
	КонецПопытки;	
	
	Возврат Истина;
	
КонецФункции

#Область ЛогированиеПроцедурыОбмена

Функция ДобавитьЗаписьВЛог(СтруктураСообщения, ТекстСообщения, ТипЗаписиВЛог = Неопределено) Экспорт
							
	Если ТипЗаписиВЛог = Неопределено Тогда		
		ТипЗаписиВЛог = ТипЗаписиВЛог_Информация();		
	КонецЕсли;

	Если ЗначениеЗаполнено(СтруктураСообщения.Логирование) Тогда
		СтруктураСообщения.Логирование = СтруктураСообщения.Логирование + Символы.ПС;	
	КонецЕсли;
	
	ВариантыСообщений = Новый Соответствие;
	ВариантыСообщений.Вставить("Ошибка", 							НСтр("ru='!Ошибка! [%1] : %2'"));
	ВариантыСообщений.Вставить("НекритичнаяОшибкаПоискаПоСсылке", 	НСтр("ru='!Некритичная ошибка поиска по ссылке! [%1] : %2'"));
	ВариантыСообщений.Вставить("НекритичнаяОшибка", 				НСтр("ru='!Некритичная ошибка! [%1] : %2'"));
	ВариантыСообщений.Вставить("ОшибкаПроведенияДокумента", 		НСтр("ru='!Ошибка проведения документа! [%1] : %2'"));
	
	ШаблонСообщения = ВариантыСообщений.Получить(ТипЗаписиВЛог.ТипСообщения);
	Если ШаблонСообщения = Неопределено Тогда
		ШаблонСообщения = НСтр("ru='[%1] : %2'");	
	КонецЕсли;	
	
	Логирование = СтрШаблон(ШаблонСообщения, 
		Формат(ТекущаяДатаСеанса(), "ДФ='dd.MM.yyyy HH:mm:ss'"),
		ТекстСообщения);
	
	СтруктураСообщения.Логирование = СтруктураСообщения.Логирование + Логирование;
	
	Если ТипЗаписиВЛог.ЭтоОшибка Тогда 
		СтруктураСообщения.ЕстьОшибка = Истина;
	КонецЕсли;	
	
	// A2105505-1430
	Если ТипЗаписиВЛог.ЭтоОшибка
        И ТипЗаписиВЛог.ЭтоПоискСсылки      
		И СтруктураСообщения.Свойство("ОшибкиПоискаДанныхИнтеграции") Тогда
		
		ОбъектМетаданных = ТипЗаписиВЛог.СвойстваЖурналаРегистрации.ОбъектМетаданных;    
		
		ОшибкаПоиска = Новый Структура;
		ОшибкаПоиска.Вставить("ОбъектМетаданных", ОбъектМетаданных);
		ОшибкаПоиска.Вставить("ТекстСообщения", ТекстСообщения);
		ОшибкаПоиска.Вставить("ИсходныеДанные", ТипЗаписиВЛог.ИсходныеДанные);
		
		СтруктураСообщения.ОшибкиПоискаДанныхИнтеграции.Добавить(ОшибкаПоиска);
		
	КонецЕсли;        
			
	Если ТипЗаписиВЛог.Свойство("УточненноеСостояние")
		// A2105505-1585  
		// Состояние "Устаревшие данные" является приоритетным
		И СтруктураСообщения.УточненноеСостояние <> 
			Перечисления.КР_СостоянияСообщенийОбмена.УстаревшиеДанные Тогда 
		
		СтруктураСообщения.УточненноеСостояние = ТипЗаписиВЛог.УточненноеСостояние; 
		
	КонецЕсли;
	
	Если ТипЗаписиВЛог.Свойство("СвойстваЖурналаРегистрации") Тогда 
		СформироватьТекстЗаписиЖурналаРегистрации(СтруктураСообщения, 
			ТекстСообщения, ТипЗаписиВЛог.ЭтоОшибка, ТипЗаписиВЛог.СвойстваЖурналаРегистрации);		
	КонецЕсли;
		
КонецФункции

Процедура ДобавитьВЛогСообщенияПользователю(СтруктураСообщения)
	// перенесем все накопленные сообщения пользователю в лог
	МассивСообщенийСеанса = ПолучитьСообщенияПользователю(Истина);
	Если МассивСообщенийСеанса.Количество() Тогда
		ТекстСообщения = НСтр("ru='В ходе работы задания получены сообщения пользователю'");
		ДобавитьЗаписьВЛог(СтруктураСообщения, ТекстСообщения);
		Для Каждого СообщениеПользователю Из МассивСообщенийСеанса Цикл
			ДобавитьЗаписьВЛог(СтруктураСообщения, СообщениеПользователю.Текст);	
		КонецЦикла;
	КонецЕсли;	
КонецПроцедуры

Функция ТипЗаписиВЛог_Информация(
	ОбъектМетаданных = Неопределено, Данные = Неопределено, СобытиеЖурналаРегистрации = Неопределено, ТипСообщения = "") Экспорт 
	
	Параметры = Новый Структура;
	Параметры.Вставить("ЭтоОшибка", Ложь);
	Параметры.Вставить("ЭтоПоискСсылки", Ложь);
	Параметры.Вставить("ТипСообщения", ТипСообщения);
			
	СвойстваЖурналаРегистрации = Новый Структура;             
	Если ОбъектМетаданных <> Неопределено Тогда 
		СвойстваЖурналаРегистрации.Вставить("ОбъектМетаданных", ОбъектМетаданных);
	КонецЕсли;
	Если ЗначениеЗаполнено(Данные) Тогда 
		СвойстваЖурналаРегистрации.Вставить("Данные", Данные);   
	КонецЕсли;
	Если СобытиеЖурналаРегистрации <> Неопределено Тогда 
 		СвойстваЖурналаРегистрации.Вставить("СобытиеЖурналаРегистрации", СобытиеЖурналаРегистрации);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СвойстваЖурналаРегистрации) Тогда 
		Параметры.Вставить("СвойстваЖурналаРегистрации", СвойстваЖурналаРегистрации);   
	КонецЕсли;
	Параметры.Вставить("ДополнительныеПараметры", Новый Структура);
		
	Возврат Параметры;  
	
КонецФункции	

Функция ТипЗаписиВЛог_ИнформацияУстаревшиеДанные(
	ОбъектМетаданных = Неопределено, Данные = Неопределено, СобытиеЖурналаРегистрации = Неопределено) Экспорт 
	
	Параметры = ТипЗаписиВЛог_Информация(ОбъектМетаданных, Данные, СобытиеЖурналаРегистрации, "УстаревшиеДанные");
	Параметры.Вставить("УточненноеСостояние", Перечисления.КР_СостоянияСообщенийОбмена.УстаревшиеДанные);
	
	Возврат Параметры;  
	
КонецФункции

Функция ТипЗаписиВЛог_Ошибка(
	ОбъектМетаданных = Неопределено, Данные = Неопределено, СобытиеЖурналаРегистрации = Неопределено) Экспорт 
	
	Параметры = ТипЗаписиВЛог_Информация(ОбъектМетаданных, Данные, СобытиеЖурналаРегистрации, "Ошибка");
	Параметры.ЭтоОшибка = Истина;
	
	Возврат Параметры;  
	
КонецФункции

Функция ТипЗаписиВЛог_ОшибкаСериализации() Экспорт 
	
	Параметры = ТипЗаписиВЛог_Информация(, , , "ОшибкаСериализации");
	Параметры.ЭтоОшибка = Истина;
	Параметры.Вставить("УточненноеСостояние", Перечисления.КР_СостоянияСообщенийОбмена.ОшибкаСериализации);
	
	Возврат Параметры;  
	
КонецФункции

Функция ТипЗаписиВЛог_ОшибкаПроведенияДокумента(
	ОбъектМетаданных = Неопределено, Данные = Неопределено, СобытиеЖурналаРегистрации = Неопределено) Экспорт 
	
	Параметры = ТипЗаписиВЛог_Информация(ОбъектМетаданных, Данные, СобытиеЖурналаРегистрации, "ОшибкаПроведенияДокумента");
	Параметры.ЭтоОшибка = Истина;
	Параметры.Вставить("УточненноеСостояние", Перечисления.КР_СостоянияСообщенийОбмена.ОшибкаПроведенияДокумента);
	
	Возврат Параметры;  
	
КонецФункции

Функция ТипЗаписиВЛог_ОшибкаПоискаСсылки(ОбъектМетаданных, ИсходныеДанные = Неопределено) Экспорт 
	
	Параметры = ТипЗаписиВЛог_Информация(ОбъектМетаданных, "ОшибкаПоискаСсылки");
	Параметры.ЭтоОшибка = Истина; 
	Параметры.ЭтоПоискСсылки = Истина; 
	Параметры.Вставить("УточненноеСостояние", Перечисления.КР_СостоянияСообщенийОбмена.ОшибкаПоискаСсылки);

	Параметры.Вставить("ИсходныеДанные", ИсходныеДанные);
	
	Возврат Параметры;  
	
КонецФункции	

// Не является ошибкой но пишется в журнал регистрации с предопределенным событием
Функция ТипЗаписиВЛог_НекритичнаяОшибкаПоискаСсылки(ОбъектМетаданных, ИсходныеДанные = Неопределено) Экспорт 
	
	СобытиеЖР = "НекритичнаяОшибкаПоискаСсылки";
	Параметры = ТипЗаписиВЛог_Информация(ОбъектМетаданных, Неопределено, СобытиеЖР, СобытиеЖР);
	Параметры.ЭтоПоискСсылки = Истина; 

	Параметры.Вставить("ИсходныеДанные", ИсходныеДанные);
	
	Возврат Параметры;  
	
КонецФункции	

// Не является ошибкой но пишется в журнал регистрации с предопределенным событием
Функция ТипЗаписиВЛог_НекритичнаяОшибка(ОбъектМетаданных) Экспорт 

	СобытиеЖР = "НекритичнаяОшибка";
	Параметры = ТипЗаписиВЛог_Информация(ОбъектМетаданных, Неопределено, СобытиеЖР, СобытиеЖР);
	
	Возврат Параметры;  
	
КонецФункции	

Функция СформироватьТекстЗаписиЖурналаРегистрации(СтруктураСообщения, ТекстСообщения, ЭтоОшибка, СвойстваЖурналаРегистрации)
	
	Если ЭтоОшибка Тогда
		УровеньСобщенияЖурнала = УровеньЖурналаРегистрации.Ошибка;
	Иначе
		УровеньСобщенияЖурнала = УровеньЖурналаРегистрации.Информация;	
	КонецЕсли;
	
	Если ТипЗнч(СвойстваЖурналаРегистрации) <> Тип("Структура") Тогда
		СвойстваЖурналаРегистрации = Новый Структура;		
	КонецЕсли;
	
	ОбъектМетаданных = Неопределено;  
	Данные = Неопределено;
	КлючЗаписи = Неопределено;
	СобытиеЖурналаРегистрации = Неопределено;
	СвойстваЖурналаРегистрации.Свойство("ОбъектМетаданных", ОбъектМетаданных);
	СвойстваЖурналаРегистрации.Свойство("Данные", Данные);	
	
	Если Не СвойстваЖурналаРегистрации.Свойство("СобытиеЖурналаРегистрации", СобытиеЖурналаРегистрации)
		Или Не ЗначениеЗаполнено(СобытиеЖурналаРегистрации) Тогда 	
		СобытиеЖурналаРегистрации = СтруктураСообщения.СобытиеЖурналаРегистрации;
	Иначе
		СобытиеЖурналаРегистрации = "RabbitMQ." + СобытиеЖурналаРегистрации;
	КонецЕсли;		
		
	Если Не СтруктураСообщения.Свойство("КлючСообщения", КлючЗаписи) Тогда
		СтруктураСообщения.Свойство("КлючИнтеграции", КлючЗаписи);		
	КонецЕсли;	
	
	ТекстЗаписиЖурнала = НСтр("ru='%1
		|%2
		|%3'");
	
	ДополнительныеСвойстваЖР = ОбщегоНазначения.СкопироватьРекурсивно(СвойстваЖурналаРегистрации);
	ДополнительныеСвойстваЖР.Удалить("ОбъектМетаданных");
	ДополнительныеСвойстваЖР.Удалить("Данные");
	ДополнительныеСвойстваЖР.Удалить("СобытиеЖурналаРегистрации");
	Если ДополнительныеСвойстваЖР.Количество() = 0 Тогда
		ТектДополнительныхСвойств = "";	
	Иначе
		ТектДополнительныхСвойств = КР_ФункцииРаботыJSON.КонвертироватьСтруктуруВJSONОбъект(ДополнительныеСвойстваЖР);	
	КонецЕсли;
	
	ТекстЗаписиЖурнала = СтрШаблон(ТекстЗаписиЖурнала, 
		КлючЗаписи,
		ТекстСообщения,
		ТектДополнительныхСвойств);
		
	ЗаписьЖурналаРегистрации(
		СобытиеЖурналаРегистрации,
		УровеньСобщенияЖурнала, ОбъектМетаданных, Данные,
		ТекстЗаписиЖурнала);
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция СформироватьСтруктуруИсходящегоСообщения(ВыборкаСообщения, НаименованиеОтправителя)

	СтруктураСообщения = Новый Структура("КлючСообщения,ТочкаОбмена,Маршрутизация,Логирование");
	ЗаполнитьЗначенияСвойств(СтруктураСообщения, ВыборкаСообщения);
	СтруктураСообщения.Вставить("ЕстьОшибка", Ложь);
	СтруктураСообщения.Вставить("ДатаОтправки", ТекущаяДатаСеанса());	
	
	URIПространстваИмен = "http://www.zolla.rabbitmq.data.org";	
	Фабрика = ФабрикаXDTO;	
	//Проверка использования сжатия
// << 08.11.2023 Петухов А.В., Фактор, #3330
	//ИспользоватьСжатиеСообщений = КР_ДополнительныеНастройкиПовтИсп.ИспользоватьСжатиеСообщений();
	//УсловиеСжатияВыполнено		= ?(ИспользоватьСжатиеСообщений И ВыборкаСообщения.ТочкаОбмена = "Stores", Истина, Ложь);
	УсловиеСжатияВыполнено = КР_ДополнительныеНастройкиПовтИсп.ИспользоватьСжатиеСообщений(СтруктураСообщения.ТочкаОбмена);
// >> 08.11.2023 Петухов А.В., Фактор, #3330
	//	
	ТипСообщение = Фабрика.Тип(URIПространстваИмен, "Message");
	ОбъектСообщение = Фабрика.Создать(ТипСообщение);

	ОбъектСообщение.Sender 		= НаименованиеОтправителя; // изменить на настройки синхронизации	
	ОбъектСообщение.SendTime 	= СтруктураСообщения.ДатаОтправки;
	
	ОбъектСообщение.ID 			= ВыборкаСообщения.КлючСообщения;
	ОбъектСообщение.Time 		= ВыборкаСообщения.ДатаСообщения;
	ОбъектСообщение.TimeID 		= ВыборкаСообщения.МоментРегистрации;	
	//Формирование тела сообщения исходя из выполнения условий сжатия
	////ОбъектСообщение.Data 		= ВыборкаСообщения.ТелоСообщения;
// << 25.12.2023 Петухов А.В., Фактор, #3553
	//ОбъектСообщение.DataPacked  = ?(УсловиеСжатияВыполнено, Новый ХранилищеЗначения(ВыборкаСообщения.ТелоСообщения, Новый СжатиеДанных (9)), Неопределено); 	
	//ОбъектСообщение.Data 		= ?(УсловиеСжатияВыполнено, "", ВыборкаСообщения.ТелоСообщения);
	
	////Вариант 1. Без проверки:
	//ОбъектСообщение.DataPacked  = ?(УсловиеСжатияВыполнено, ВыборкаСообщения.ТелоСообщенияСжатое, Неопределено); 	
	//ОбъектСообщение.Data 		= ?(УсловиеСжатияВыполнено, "", ВыборкаСообщения.ТелоСообщения);

	//Вариант 2. С проверкой:
	// Учтём возможность того, что условие сжатия изменилось после формирования сообщений
	Если УсловиеСжатияВыполнено Тогда							// Требуется отправить сжатое
		ОбъектСообщение.Data = "";
		Если ПустаяСтрока(ВыборкаСообщения.ТелоСообщения) Тогда
			ОбъектСообщение.DataPacked  = ВыборкаСообщения.ТелоСообщенияСжатое;
		Иначе
			ТелоСообщенияРаспакованное = ВыборкаСообщения.ТелоСообщенияСжатое.Получить();
			Если ТелоСообщенияРаспакованное = Неопределено Тогда	// Сообщение было не сжато
				ОбъектСообщение.DataPacked  = Новый ХранилищеЗначения(ВыборкаСообщения.ТелоСообщения, Новый СжатиеДанных (9));
			Иначе
				ОбъектСообщение.DataPacked  = ВыборкаСообщения.ТелоСообщенияСжатое;
			КонецЕсли;
		КонецЕсли;
	Иначе														// Требуется отправить несжатое
		ОбъектСообщение.DataPacked = Неопределено;
		Если ПустаяСтрока(ВыборкаСообщения.ТелоСообщения) Тогда
			ТелоСообщенияРаспакованное = ВыборкаСообщения.ТелоСообщенияСжатое.Получить();
			Если ТелоСообщенияРаспакованное = Неопределено Тогда
				ОбъектСообщение.Data = "";
			Иначе
				ОбъектСообщение.Data = ТелоСообщенияРаспакованное;
			КонецЕсли;
		Иначе
			ОбъектСообщение.Data = ВыборкаСообщения.ТелоСообщения;
		КонецЕсли;
	КонецЕсли;
// >> 25.12.2023 Петухов А.В., Фактор, #3553
	ОбъектСообщение.DataType 	= ВыборкаСообщения.ТипДанных;	
	ОбъектСообщение.Log 		= ВыборкаСообщения.Логирование;	
		
	СтруктураСообщения.Вставить("ОбъектСообщение", ОбъектСообщение);
	СтруктураСообщения.Вставить("УточненноеСостояние", Неопределено);	
	
	Возврат СтруктураСообщения;
	
КонецФункции

Функция ПолучитьВходящееСообщениеДляОбработки(
	СтруктураСообщения, КлючСообщения, СтатусыОбработки, ИдентификаторГруппировкиДанных = Неопределено)
	
	БлокироватьЗапись = Не ЗначениеЗаполнено(ИдентификаторГруппировкиДанных);
	
	Попытка        
		
		Если БлокироватьЗапись Тогда   
			
			НачатьТранзакцию();
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КР_ВходящиеСообщения");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			ЭлементБлокировки.УстановитьЗначение("КлючСообщения", КлючСообщения);
			Блокировка.Заблокировать();	
			
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.Текст =   
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	КР_ВходящиеСообщения.КлючСообщения КАК КлючСообщения,
			|	КР_ВходящиеСообщения.ТипДанных КАК ТипДанных,
			|	КР_ВходящиеСообщения.Отправитель КАК Отправитель,
			|	КР_ВходящиеСообщения.ОчередьОбмена КАК ОчередьОбмена,
			|	КР_ВходящиеСообщения.ТелоСообщения КАК ТелоСообщения,
			// << 25.12.2023 Петухов А.В., Фактор, #3553
			|	КР_ВходящиеСообщения.ТелоСообщенияСжатое КАК ТелоСообщенияСжатое,
			// >> 25.12.2023 Петухов А.В., Фактор, #3553
			// << 28.03.2024 Петухов А.В., Фактор, #3915
			|	КР_ВходящиеСообщения.КоличествоПопытокОбработки КАК КоличествоПопытокОбработки,
			// >> 28.03.2024 Петухов А.В., Фактор, #3915
			|	КР_ВходящиеСообщения.МоментРегистрации КАК МоментРегистрации,
			|	КР_ВходящиеСообщения.ДатаРегистрации КАК ДатаРегистрации
			|ИЗ
			|	РегистрСведений.КР_ВходящиеСообщения КАК КР_ВходящиеСообщения
			|ГДЕ
			|	КР_ВходящиеСообщения.КлючСообщения = &КлючСообщения
			|	И КР_ВходящиеСообщения.Состояние В(&СтатусыОбработки)
			|
			|УПОРЯДОЧИТЬ ПО
			|	КР_ВходящиеСообщения.ДатаРегистрации,
			|	КР_ВходящиеСообщения.МоментРегистрации";
		
		Запрос.УстановитьПараметр("КлючСообщения", КлючСообщения);
		Запрос.УстановитьПараметр("СтатусыОбработки", СтатусыОбработки);
		
		РезультатЗапроса = Запрос.Выполнить();
		Если РезультатЗапроса.Пустой() Тогда      
			
			Если ТранзакцияАктивна() Тогда 
				ОтменитьТранзакцию();   
			КонецЕсли;	            
			
			Возврат Ложь;
		КонецЕсли;
		
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		ВыборкаДетальныеЗаписи.Следующий();
		
		СтруктураСообщения = ПолучитьСтруктуруВходящегоСообщения();
		ЗаполнитьЗначенияСвойств(СтруктураСообщения, ВыборкаДетальныеЗаписи);
		
		МенеджерЗаписи = РегистрыСведений.КР_ВходящиеСообщения.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.КлючСообщения = СтруктураСообщения.КлючСообщения;			
		МенеджерЗаписи.Прочитать();
		МенеджерЗаписи.Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Обрабатывается;  
		Если ЗначениеЗаполнено(ИдентификаторГруппировкиДанных) Тогда 
			МенеджерЗаписи.ИдентификаторГруппировкиДанных = ИдентификаторГруппировкиДанных;
		КонецЕсли;	
		МенеджерЗаписи.Записать(Истина);
		
		Если БлокироватьЗапись Тогда 
			ЗафиксироватьТранзакцию();    
		КонецЕсли;
		
		Возврат Истина;
		
	Исключение
		ОтменитьТранзакцию();
		ТекстСообщения = НСтр("ru='Исключительная ошибка итерации выбора сообщений для обработки:
			|%1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации("RabbitMQ.ОбработкаСообщений",УровеньЖурналаРегистрации.Ошибка,,,ТекстСообщения);
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

Функция ЗарегистрироватьОбработкуВходящегоСообщения(СтруктураСообщения)
	
	МенеджерЗаписи = РегистрыСведений.КР_ВходящиеСообщения.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.КлючСообщения = СтруктураСообщения.КлючСообщения;			
	МенеджерЗаписи.Прочитать();			
	МенеджерЗаписи.ДатаОбработки = ТекущаяДатаСеанса();
	МенеджерЗаписи.КоличествоПопытокОбработки = МенеджерЗаписи.КоличествоПопытокОбработки + 1;
	
	РазделительЛога = НСтр("ru='-------------------------------------------------
		|Итерация разбора сообщения №%1 от %2'");
	РазделительЛога = СтрШаблон(РазделительЛога, МенеджерЗаписи.КоличествоПопытокОбработки, МенеджерЗаписи.ДатаОбработки);	
	
	//МенеджерЗаписи.Логирование = МенеджерЗаписи.Логирование + Символы.ПС
	//	+ РазделительЛога + Символы.ПС
	//	+ СтруктураСообщения.Логирование;
	МенеджерЗаписи.Логирование = РазделительЛога + Символы.ПС + СтруктураСообщения.Логирование;
	
	Если СтруктураСообщения.УточненноеСостояние <> Неопределено Тогда
		Состояние = СтруктураСообщения.УточненноеСостояние;		
	ИначеЕсли СтруктураСообщения.ЕстьОшибка Тогда
		Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Ошибка;
	Иначе
		Состояние = Перечисления.КР_СостоянияСообщенийОбмена.Обработано;
	КонецЕсли;
	
	МенеджерЗаписи.Состояние = Состояние;    

	// A2105505-1404 
	МодульКонвертации = КР_ОбщегоНазначениеСервер;
	Данные = Новый Массив;
	Для Каждого Ссылка Из СтруктураСообщения.СсылкиНаОбъекты Цикл 
		Данные.Добавить(МодульКонвертации.СсылкаВСтруктуру(Ссылка));
	КонецЦикла;
	СсылкиНаОбъекты = МодульКонвертации.ДанныеВJSON(Данные);
	
	МенеджерЗаписи.СписокСсылокНаОбъекты = СсылкиНаОбъекты;	
	
	МенеджерЗаписи.Записать(Истина);
	
	// A2105505-1430
	Для Каждого ОшибкаПоиска Из СтруктураСообщения.ОшибкиПоискаДанныхИнтеграции Цикл 
		
		РегистрыСведений.КР_ОшибкиПоискаДанныхИнтеграции.ДобавитьЗапись(ОшибкаПоиска, СтруктураСообщения);		
		
	КонецЦикла;        
	
КонецФункции

Процедура УстановитьОчередьОбмена(ИмяОчереди, СообщениеОбъект, МенеджерЗаписи)
	
	ТипДанных = СообщениеОбъект.DataType;
	
	ШаблонИмениНовойОчереди = "%1_%2";
	
	// << 26.10.2023 Фомичев А.Е
	СтрокаТиповДанных = КР_ДополнительныеНастройкиПовтИсп.ОбъектыИнтеграцииСИндивидуальнойОчередьюОбработки();
	МассивТиповДанных = СтрРазделить(СтрокаТиповДанных, ",", Ложь);
	// >> 26.10.2023 Фомичев А.Е
	//МассивТиповДанных = СтрРазделить(
	//	Константы.КР_ОбъектыИнтеграцииСИндивидуальнойОчередьюОбработки.Получить(), ",", Ложь);
	
	Если ТипДанных = "GoodsRelocationObject" 
		И СтрНайти(СообщениеОбъект.Data, """InsideShop"":true") Тогда 
		ОчередьОбмена = СтрШаблон(ШаблонИмениНовойОчереди, ИмяОчереди, "GoodsRelocationObject_InsideShop");
	ИначеЕсли МассивТиповДанных.Найти(ТипДанных) <> Неопределено Тогда   
		ОчередьОбмена = СтрШаблон(ШаблонИмениНовойОчереди, ИмяОчереди, ТипДанных);
	Иначе
		ОчередьОбмена = ИмяОчереди;
	КонецЕсли;	
		
	МенеджерЗаписи.ОчередьОбмена = ОчередьОбмена;
	
КонецПроцедуры
#КонецОбласти

